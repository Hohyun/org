#+LAST_MOBILE_CHANGE: 2015-09-15 21:19:53
* KNOU
** Alogorithm 특론                                                 :computer:
*** DONE W1. 알고리즘의 기본개념
*** DONE W2. 욕심쟁이 방법
    CLOSED: [2015-09-21 Mon 14:51] DEADLINE: <2015-09-12 토>
    :PROPERTIES:
    :ID:       18852C46-16EB-429D-A45C-FBEA7AC37660
    :END:
*** DONE 알고리즘 과제 1                                           :homework:
  CLOSED: [2015-10-12 Mon 11:14] DEADLINE: <2015-10-03 Sat>
  :PROPERTIES:
  :ID:       82A9330F-FBCD-4A06-BB12-D5F070CD5653
  :END:
*** TODO 알고리즘 과제 2                                           :homework:
    DEADLINE: <2015-10-26 Mon>
    :PROPERTIES:
    :ID:       BE6786E8-BA93-473E-8D51-C1C4E1801209
    :END:
  - 최소편집거리, 이중해싱, 텍스트매칭 알고리즘(KMP, 보이어 무어)
** 컴포넌트 프로그래밍
*** DONE W1. 컴포넌트 프로그래밍의 기초
*** DONE W2. J2EE Architecture
    CLOSED: [2015-09-15 Tue 21:19] DEADLINE: <2015-09-12 토>
    :PROPERTIES:
    :ID:       06BB0434-1D2A-4F87-B8D6-3E292E7D46F5
    :END:

*** DONE 컴포넌트 프로그래밍 과제 (중간고사 대체)
  CLOSED: [2015-10-23 Fri 13:01] DEADLINE: <2015-10-24 Sat>
  - [ ] 웹로직 서버 설치 과정을 강의자료에 있는 것 처럼 본인 컴퓨터에 설치하는 과정을 단계별로 캡쳐해서 제출하기
  - [ ] 웹로직 서버 설치 후, 거기에 있는 HTML 실습예제, JSP 실습 예제, 서블릿 실습예제 코딩해서 소스화일과 실행 결과 캡쳐해서 제출할 것
  - [ ] 강의자료에 있는 JSP 프로그램 예제를 실습해서 소스화일과 실행 결과 화면 캡쳐해서 제출할 것
  - [ ] 각 소스코드와 실행결과의 내용을 간단히 설명할 것
**** TODO 제출방법
     :PROPERTIES:
     :ID:       0C1A7FDF-1312-4940-AC4D-9DFBE1C0A611
     :END:
  - A4 용지에 작성하여 과제방에 올려주세요
  - 범위: 1강 - 6강

* Programming                                                      :computer:
** Clojure Programming
   - [ ] Macro Programming
   - [ ] modern-cljs
** DONE Gnus setup
   CLOSED: [2015-09-16 Wed 14:07]
   :PROPERTIES:
   :ID:       979ED662-1AF1-4352-8F29-0A94455F97AA
   :END:
** DONE AucTeX setup
   CLOSED: [2015-10-14 Wed 11:40]
   :PROPERTIES:
   :ID:       5E2FF472-70AA-4999-9CDA-77F40E19642C
   :END:

* 알고리즘 과제 1
** 1. 알고리즘의 요소 및 실생활의 적용 사례
*** 알고리즘이라면 꼭 갖추어야 할 요소
1. 0개 이상의 입력과 하나 이상의 출력이 있어야 한다.
2. 각 단계가 모호하지 않고 명확해야 한다.
3. 한정된 수의 작업 후에는 반드시 종료해야 한다.
4. 모든 명령이 수행 가능해야 한다.
5. 효율적이어야 한다. 알고리즘을 실생활에 적용하기 위해서 아주 중요한 요소이다. 무조건 해결 가능하다고 사용할 수 있는 것이 아니라, 적용 가능할 정도의 효율성이 필요하다. 알고리즘이 O(N^2)의 성능을 보인다면 데이터량이 크게 증가하면 현실적으로 사용하기 어렵지만, O(NlogN) 이상의 성능을 보인다면, 데이터량이 아무리 증가해도 적용 가능하다.

*** 실생활에서 알고리즘이 사용되고 있는 사례
요즈음 운전자들에게 필수가 되어버린 네비게이션이 실생활에서 발견할 수 있는 알고리즘의 좋은 예가 아닐까 생각된다. 알고리즘의 요소라는 관점에서 볼 때, 네비게이션을 열여 목적지를 선택하고 검색을 누르면 최적 경로를 찾아 화면에 보여주는데, 이것이 0개 이상의 입력과 하나 이상의 출력의 조건에 해당한다. 또한 네비게이션 검색과정은 모호하지 않고 명확하며, 모든 명령이 수행 가능하지 않다면  프로그램으로 구현이 불가능할 것이다. 그리고 활용 측면에서 충분히 빠르게 동작하지 않는다면 사용자는 앱을 사용하려 하지 않을 것이므로, 효율적으로 동작해야만 할 것이다.

** 2. 최소신장나무 알고리즘
*** 크루스칼 알고리즘
**** 가중치가 증가하는 순으로 간선을 정렬한다.
   - 1(g,h), 2(c,i), 2(f,g), 4(a,b), 4(c,f), 6(g,i), 7(c,d), 7(h,i), 8(a,h), 8(b,c), 9(d,e), 10(e,f), 11(b,h), 14(d,f)
   - 이 때 모든 정점은 서로 다른 연결성분에 속한다.

**** 가중치가 낮은 간선부터 차래대로 간선을 추가한다. 단 같은 연결성분에 속하는 정점은 추가할 수 없다.
   1. (g,h) 추가 -- 현재 연결성분 {g,h}
   2. (c,i) 추가 -- 현재 연결성분 {g,h}, {c,i}
   3. (f,g) 추가 -- 현재 연결성분 {f,g,h}, {c,i}
   4. (a,b) 추가 -- 현재 연결성분 {f,g,h}, {c,i}, {a,b}
   5. (c,f) 추가 -- 현재 연결성분 {c,f,g,h,i}, {a,b}
   6. (g,i) 추가해야 하나 g와 i가 동일 연결성분에 속하므로 추가하지 않는다.
   7. (c,d) 추가 -- 현재 연결성분 {c,d,f,g,h,i}, {a,b}
   8. (h,i) 추가해야 하나 h와 i가 동일 연결성분에 속하므로 추가하지 않는다.
   9. (a,h) 추가 -- 현재 연결성분 {a,b,c,d,f,g,h,i}
  10. (b,c) 추가해야 하나 b와 c가 동일 연결성분에 속하므로 추가하지 않는다.
  11. (d,e) 추가 -- 현재 연결성분 {a,b,c,d,e,f,g,h,i}
      모든 정점이 같은 연결성분에 속하므로 남은 간선 (e,f), (b,h), (d,f)는 추가하지 않고 종료한다.
      이렇게 구해진 최소 신장 나무는 아래 그림과 같으며, 가중치의 합은 39이다.

*** 프림 알고리즘 (정점 a에서 시작하는 경우)
프림 알고리즘은 이미 선택된 정점집합 S와 나머지 정점집합 V-S를 잇는 최소간선을 택하여 최소신장나무를 만들어 나간다.

**** 풀이 과정
  1. S = {a}로 시작한다. S와 S-V를 잇는 간선은 4(a,b)와 8(a,h)가 있고, 이 중 최소인 (a,b)를 선택하면 S = {a,b}
  2. S와 S-V를 잇는 간선은 8(b,c)와 8(a,h)가 있는데, 가중치가 같으므로 임의로 (b,c)를 선택하면 S = {a,b,c}
  3. S와 S-V를 잇는 간선은 2(c,i), 7(c,d), 8(a,h)가 있고, 이 중 최소인 (c,i)를 선택하면 S =
{a,b,c,i}
  4. S와 S-V를 잇는 간선은 4(c,f), 6(i,g), 7(c,d), 7(i,h), 8(a,h)가 있고, 이 중 최소인 (c,f)를 선택하면 S = {a,b,c,f,i}
  5. S와 S-V를 잇는 간선은 2(f,g}, 6(i,g), 7(i,h), 7(c,d), 8(a,h), 10(f,e), 14(f,d}가 있고, 이 중 최소인 (g,f)를 선택하면 S = {a,b,c,f,g,i}
  6 S와 S-V를 잇는 간선은 1(g,h), 7(c,d), 7(i,h), 8(a,h), 10(f,e), 14(f,d)가 있고, 이 중 최소인 (g,h)를 선택하면 S = {a,b,c,f,g,h,i}
  7. S와 S-V를 잇는 간선은 7(c,d), 10(f,e), 14(d,f)가 있고, 이 중 최소인 (c,d)를 선택하면 S = {a,b,c,d,f,g,h,i}
  8. S와 S-V를 잇는 간선은 9(d,e), 10(f,e)가 있고, 이 중 최소인 (d,e)를 선택하면 S = {a,b,c,d,e,f,g,h,i}  S와 V가 같으므로 종료한다. 이렇게 구해진 최소 신장 나무는 아래 그림과 같으며, 가중치의 합은 39이다.

** 3. 졍렬 알고리즘
*** Quick sort

   lo   j   hi    :   0  1  2  3  4  5  6  7  8  9 10 11
--------------------------------------------------------
- Initial Values  :  13 19  9  5 12  8  7  4 21  2  6 11
E Exch ( 1<-->11) :     11                            19
E Exch ( 8<-->10) :                           6    21
P Exch ( 0<--> 9) :   2                         13
-   0   9   11    :   2 11  9  5 12  8  7  4  6 13 21 19
--------------------------------------------------------
P Exch ( 0<--> 0) :   2
-   0   0    8    :   2 11  9  5 12  8  7  4  6 13 21 19
--------------------------------------------------------
E Exch ( 4<--> 8) :               6          12
P Exch ( 1<--> 7) :      4                11
-   1   7    8    :   2  4  9  5  6  8  7 11 12 13 21 19
--------------------------------------------------------
P Exch ( 1<--> 1) :      2
-   1   1    6    :   2  4  9  5  6  8  7 11 12 13 21 19
--------------------------------------------------------
P Exch ( 2<--> 6) :         7           9
-   2   6    6    :   2  4  7  5  6  8  9 11 12 13 21 19
--------------------------------------------------------
P Exch ( 2<--> 4) :         6     7
-   2   4    5    :   2  4  6  5  7  8  9 11 12 13 21 19
--------------------------------------------------------
P Exch ( 2<--> 3) :         5  6
-   2   3    3    :   2  4  5  6  7  8  9 11 12 13 21 19
--------------------------------------------------------
P Exch (10<-->11) :                                19 21
-  10  11   11    :   2  4  5  6  7  8  9 11 12 13 19 21
--------------------------------------------------------
- Result          :   2  4  5  6  7  8  9 11 12 13 19 21

*** Merge sort

merge(lo, mid, hi):   0  1  2  3  4  5  6  7  8  9 10 11
--------------------------------------------------------
- Initial Values  :  13 19  9  5 12  8  7  4 21  2  6 11
merge( 0,   0,  1):  13 19  9  5 12  8  7  4 21  2  6 11
merge( 0,   1,  2):   9 13 19  5 12  8  7  4 21  2  6 11
merge( 3,   3,  4):   9 13 19  5 12  8  7  4 21  2  6 11
merge( 3,   4,  5):   9 13 19  5  8 12  7  4 21  2  6 11
merge( 0,   2,  5):   5  8  9 12 13 19  7  4 21  2  6 11
merge( 6,   6,  7):   5  8  9 12 13 19  4  7 21  2  6 11
merge( 6,   7,  8):   5  8  9 12 13 19  4  7 21  2  6 11
merge( 9,   9, 10):   5  8  9 12 13 19  4  7 21  2  6 11
merge( 9,  10, 11):   5  8  9 12 13 19  4  7 21  2  6 11
merge( 6,   8, 11):   5  8  9 12 13 19  2  4  6  7 11 21
merge( 0,   5, 11):   2  4  5  6  7  8  9 11 12 13 19 21
--------------------------------------------------------
- Result          :   2  4  5  6  7  8  9 11 12 13 19 21


* 알고리즘 과제 2
** 1. 최소 편집거리 문제
** 2. 이중 해싱법
** 3. KMP, 보이어 무어 알고리즘
